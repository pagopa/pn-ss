AWSTemplateFormatVersion: 2010-09-09
Description: 'Example microservice deploy'

Parameters:
  ProjectName:
    Type: String
    Description: 'Usually pn can be pnXYZ where XYZ are the feature number, useful to create
      experimental environments without crash official development environment'

  AlarmSNSTopicArn:
    Type: String
    Description: ARN of alarm topic

  # WebApiDnsName:
  #   Type: String
  #   Description: 'The DNS name used for WEB rest API.'
  
  # CorsAllowedDomains:
  #   Type: String
  #   Description: 'Comma separated list of domains allowed to make cross origin request'

  ContainerImageUri:
    Type: String
    Description: 'Exact container image URI with full repository and image digest'

  MicroserviceNumber:
    Type: Number
    Description: 'Disambiguation useful for load balancer rules'

  TemplateBucketBaseUrl:
    Type: String
    Description: 'The S3 bucket from which to fetch the templates used by this stack.'

  ECSClusterName:
    Type: String
    Description: 'The name of the ECS cluster where the microservice is going to be deployed'

  VpcEgressSubnetsIds:
    Type: String
    Description: subnets where to install PN-CONFIDENTIAL-INFO

  SubnetsIds:
    Type: String
    Description: 'subnets ids comma separated list. Where to deploy the microservice'

  VpcId:
    Type: String
    Description: 'VpcId where the microservice is going to be deployed'
  
  EcsDefaultSecurityGroup:
    Type: String
    Description: 'Default security group required by infrastructure'

  ApplicationLoadBalancerListenerArn:
    Type: String
    Description: 'Load balancer listener where HTTP endpoints is going to be registered'

  ApplicationLoadBalancerDomain:
    Type: String
    Description: 'Base URL of the load balancer where the service is going to be reachable'

  NetworkLoadBalancerLink:
    Type: String
    Description: 'network load balancer link for API-GW'
    Default: ''
  
  # LogsKinesisSourceStreamArn:
  #   Type: String
  #   Description: 'Kinesis stream that receive logs'
  
  Version:
    Type: String
    Description: 'keep track of used projects commitIds'

  PnCoreTargetEventBus:
    Type: String
    Description: 'ARN of Pn Core Event Bus where to forward external notifications'
    Default: ''

  TrailName:
    Type: String
    Description: 'Presigned Url usage trail name'
    Default: 'pn-ss-presigned-url-usage'

  SafeStorageFileAccessLogsBucketName:
    Type: String
    Default: '-'
    Description: 'presigned url usage log bucket name'

  SafeStorageFileAccessLogsBucketPathPrefix:
    Type: String
    Default: 'safeStorageObjectPutAndGetTracing'
    Description: 'Destination path into bucket name'

#### Parametri provenienti dal Template della Stack SS-Storage ####
  PnSsTableNameAnagraficaClient:
    Type: String
    Description: 'Nome della tabella SS Anagrafica Client'

  PnSsTableArnAnagraficaClient:
    Type: String
    Description: 'ARN della Tabella DynamoDB relativa alla Macchina a Stati'
  
  PnSsTableNameTipologieDocumenti:
    Type: String
    Description: 'Nome della tabella SS Tipologie Documenti'

  PnSsTableArnTipologieDocumenti:
    Type: String
    Description: 'ARN della tabella SS Tipologie Documenti'
  
  PnSsTableNameDocumenti:
    Type: String
    Description: 'Nome tabella SS Documenti'

  PnSsTableArnDocumenti:
    Type: String
    Description: 'ARN della tabella SS Documenti'

  PnSsTableDocumentiStreamArn:
    Type: String
    Description: 'ARN dello stream relativo alla tabella SS Documenti'

  PnSsBucketName:
    Type: String
    Description: 'Nome del Bucket SS'

  PnSsBucketArn:
    Type: String
    Description: 'ARN del Bucket SS'
  
  PnSsStagingBucketName:
    Type: String
    Description: 'Nome Bucket SS Staging'

  PnSsStagingBucketArn:
    Type: String
    Description: 'ARN Bucket SS Staging'

  PnSsQueueNameStagingBucket:
    Type: String
    Description: 'Nome coda per notifiche SS Staging Bucket'

  PnSsQueueArnStagingBucket:
    Type: String
    Description: 'ARN coda per notifiche SS Staging Bucket'

  PnSsQueueUrlStagingBucket:
    Type: String
    Description: 'URL coda per notifiche SS Staging Bucket'

  PnSsDLQueueNameStagingBucket:
    Type: String
    Description: 'Nome coda DLQ per notifiche SS Staging Bucket'
  
  PnSsAlarmArnQueueStagingBucket:
    Type: String
    Description: "ARN dell'allarme messaggi vecchi nella coda notifiche SS Staging Bucket "
  
  PnSsAlarmArnDLQueueStagingBucket:
    Type: String
    Description: "ARN dell'allarme per presenza di messaggi nella DLQ notifiche SS Staging Bucket "

  PnSsQueueNameGestoreBucketInvokeErrors:
    Type: String
    Description: 'Nome coda per pubblicazione errori del Gestore Bucket'

  PnSsQueueArnGestoreBucketInvokeErrors:
    Type: String
    Description: 'ARN coda per pubblicazione errori del Gestore Bucket'

  PnSsQueueUrlGestoreBucketInvokeErrors:
    Type: String
    Description: 'URL coda per pubblicazione errori del Gestore Bucket'

  PnSsDLQueueNameGestoreBucketInvokeErrors:
    Type: String
    Description: 'Nome coda DLQ per pubblicazione errori del Gestore Bucket'

  PnSsAlarmArnQueueGestoreBucketInvokeErrors:
    Type: String
    Description: "ARN dell'allarme messaggi vecchi nella coda errori del Gestore Bucket"
  
  PnSsAlarmArnDLQueueGestoreBucketInvokeErrors:
    Type: String
    Description: "ARN dell'allarme per presenza di messaggi nella DLQ errori del Gestore Bucket"
  
  PnSsQueueNameGestoreBucketInvoke:
    Type: String
    Description: 'Nome coda per pubblicazione notifiche di eventi dal bucket SS'

  PnSsQueueArnGestoreBucketInvoke:
    Type: String
    Description: 'ARN coda per pubblicazione notifiche di eventi dal bucket SS'

  PnSsQueueUrlGestoreBucketInvoke:
    Type: String
    Description: 'URL coda per pubblicazione notifiche di eventi dal bucket SS'

  PnSsDLQueueNameGestoreBucketInvoke:
    Type: String
    Description: 'Nome coda DLQ per pubblicazione notifiche di eventi dal bucket SS'

  PnSsAlarmArnQueueGestoreBucketInvoke:
    Type: String
    Description: "ARN dell'allarme messaggi vecchi nella coda notifiche di eventi sul bucket SS"
  
  PnSsAlarmArnDLQueueGestoreBucketInvoke:
    Type: String
    Description: "ARN dell'allarme per presenza di messaggi nella DLQ notifiche di eventi sul bucket SS"

  PnSsManagedPolicyName:
    Type: String
    Description: 'Nome della managed policy de lmicroservizio Safe Storage'
    Default: 'PnSsManagedPolicyName'
 
  PnSsGestoreBucketLambdaName:
    Type: String
    Description: 'Nome della Lambda function che implementa la funzionalità del Gestore Bucket'
 
  PnSsEventBusNameExternalNotification:
    Type: String
    Description: 'Nome event bus per pubblicare eventi di Gestore Disponibilita'

  PnSsEventBusArnExternalNotification:
    Type: String
    Description: 'Arn event bus per pubblicare eventi di Gestore Disponibilita'

  PnSsQueueNameEventsDLQueuePnCoreTargetEventBus:
    Type: String
    Description: 'Nome DLQ per forward degli eventi al bus PnCoreTargetEventBus'

  PnSsQueueArnEventsDLQueuePnCoreTargetEventBus:
    Type: String
    Description: 'ARN DLQ per forward degli eventi al bus PnCoreTargetEventBus'

  PnSsQueueUrlEventsDLQueuePnCoreTargetEventBus:
    Type: String
    Description: 'URL DLQ per forward degli eventi al bus PnCoreTargetEventBus'

  PnSsAlarmArnEventsDLQueuePnCoreTargetEventBus:
    Type: String
    Description: "ARN dell'allarme messaggi vecchi nella DLQ per forward degli eventi al bus PnCoreTargetEventBus"  

#### Parametri presenti nel file json di configurazione  ###
  
  PnSsUriBuilderstayHotTime:
    Type: String
    Description: 'Days parameter for restoring of Staging Buckets objects in Glacier archive'
    
  PresignedUrlMinutesLifespan:
    Type: String
    Description: 'Minuti di validità dei pre-signed url prima della scadenza'

  PnVPCDefaultSecurityGroup:
    Type: String
    Description: 'VPC default Security Group'

  PnSsGestoreRepositoryProtocol:
    Type: String
    Description: 'Protocol for connecting to pn-ss Gestore Respository'

  PnSsGestoreRepositoryPort:
    Type: String
    Description: 'Port for connecting to pn-ss Gestore Respository'

  PnSsGestoreRepositoryPathGetDocument:
    Type: String
    Description: 'Path for GetDocument towards pn-ss Gestore Respository'

  PnSsGestoreRepositoryPathPatchDocument:
    Type: String
    Description: 'Path for PatchDocument towards pn-ss Gestore Respository'

  PnSsTableDocumentiStreamMetadatiTable:
    Type: String
    Description: 'Name of the DynamoDB Stream s metadata table for the source table PnSsDocumenti'

  PnSsArubaCertId:
    Type: String
    Description: 'Aruba param CertId'

  PnSsArubaEnabledLog:
    Type: String
    Description: 'Aruba param EnabledLog'

  PnSsArubaSignWsdlUrl:
    Type: String
    Description: 'Aruba param SignWsdlUrl'
  
  PnSsArubaQname:
    Type: String
    Description: 'Aruba param Qname'

  PnSsArubaSignService:
    Type: String
    Description: 'Aruba param SignService'

  PnSsTsaIdentity:
    Type: String
    Description: 'TsaIdentity' 
    
  PnSsIdentityTimemark:
    Type: String
    Description: 'Secret ID for Identity Timemark'

  PnSsIdentitySignature:
    Type: String
    Description: 'Secret ID for Identity Signature'
  
  PnSsTimemarkUrl:
    Type: String
    Description: 'TimemarkUrl'  
  
  PnSsSecurityGroupNameSafeStorage:
    Type: String
    Description: 'GestoreBucket Security Group'

  AlarmSNSTopicName:
    Type: String
    Description: 'Topic alarm'

#### Parametri esterni indipendenti ###

  PnSsGestoreBucketReservedConcurrentExecutions:
    Type: Number
    Description: 'Maximum number of concurrent executions for Lambda Gestore Bucket'
    Default: 40

  PnSsMinTasksInstancesNumber:
    Type: Number
    Description: 'Minimum number of running instances for the microservice'
    Default: 2


Conditions:
  PnCoreTargetEventBusExists: !Not [ !Equals [!Ref PnCoreTargetEventBus, '' ] ]
  HasCloudTrailLogsBucketName: !Not [ !Equals [!Ref SafeStorageFileAccessLogsBucketName, '-' ] ]

Resources:

  # PN-TemplateBeMs microservice
  SafeStorageMicroservice:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: !Sub '${TemplateBucketBaseUrl}/fragments/ecs-service.yaml'
      Parameters:
        MicroServiceUniqueName: !Sub '${ProjectName}-safe-storage'
        CpuValue: 4096
        MemoryAmount: 8GB
        AlarmSNSTopicArn: !Ref AlarmSNSTopicArn
        ContainerImageURI: !Sub '${ContainerImageUri}'
        ContainerEnvEntry1: !Sub 'AWS_REGIONCODE=${AWS::Region}'
        ContainerEnvEntry2: !Sub 'PnSsEventBusNameExternalNotification=${PnSsEventBusNameExternalNotification}'
        ContainerEnvEntry3: !Sub 'PnSsBucketName=${PnSsBucketName}'
        ContainerEnvEntry4: !Sub 'PnSsBucketArn=${PnSsBucketArn}'
        ContainerEnvEntry5: !Sub 'PnSsStagingBucketName=${PnSsStagingBucketName}'
        ContainerEnvEntry6: !Sub 'PnSsStagingBucketArn=${PnSsStagingBucketArn}'
        ContainerEnvEntry7: !Sub 'PnSsTableNameAnagraficaClient=${PnSsTableNameAnagraficaClient}'
        ContainerEnvEntry8: !Sub 'PnSsTableNameTipologieDocumenti=${PnSsTableNameTipologieDocumenti}'
        ContainerEnvEntry9: !Sub 'PnSsTableNameDocumenti=${PnSsTableNameDocumenti}'
        ContainerEnvEntry10: !Sub 'PnSsTableDocumentiStreamArn=${PnSsTableDocumentiStreamArn}'
        ContainerEnvEntry11: !Sub 'PnSsTableDocumentiStreamMetadatiTable=${PnSsTableDocumentiStreamMetadatiTable}'
        ContainerEnvEntry12: !Sub 'PnSsQueueNameStagingBucket=${PnSsQueueNameStagingBucket}'
        ContainerEnvEntry20: !Sub 'pst=${PresignedUrlMinutesLifespan}'
        ContainerEnvEntry21: !Sub 'stayHotTime=${PnSsUriBuilderstayHotTime}'
        ContainerEnvEntry22: !Sub 'PnSsBucketLockRetentionMode=GOVERNANCE'
        ContainerEnvEntry30: !Sub 'PnSsArubaCertId=${PnSsArubaCertId}'
        ContainerEnvEntry31: !Sub 'PnSsArubaEnabledLog=${PnSsArubaEnabledLog}'
        ContainerEnvEntry32: !Sub 'PnSsArubaSignWsdlUrl=${PnSsArubaSignWsdlUrl}'
        ContainerEnvEntry33: !Sub 'PnSsArubaQname=${PnSsArubaQname}'
        ContainerEnvEntry34: !Sub 'PnSsArubaSignService=${PnSsArubaSignService}'
        ContainerEnvEntry35: !Sub 'PnSsTsaIdentity=${PnSsTsaIdentity}'
        ContainerEnvEntry36: !Sub 'PnSsIdentityTimemark=${PnSsIdentityTimemark}'
        ContainerEnvEntry37: !Sub 'PnSsIdentitySignature=${PnSsIdentitySignature}'
        ContainerEnvEntry38: !Sub 'PnSsTimemarkUrl=${PnSsTimemarkUrl}'
        ContainerEnvEntry40: !Sub 'StateMachineBaseUrl=http://${ApplicationLoadBalancerDomain}:8080'
        ContainerEnvEntry41: !Sub 'InternalBaseUrl=http://${ApplicationLoadBalancerDomain}:8080'
        MappedPaths: '/safestorage/*,/safe-storage/*'
        ECSClusterName: !Ref ECSClusterName
        Subnets: !Ref VpcEgressSubnetsIds
        VpcId: !Ref VpcId
        EcsDefaultSecurityGroup: !Ref EcsDefaultSecurityGroup
        LoadBalancerListenerArn: !Ref ApplicationLoadBalancerListenerArn
        LoadbalancerRulePriority: !Ref MicroserviceNumber
        MinTasksNumber: !Ref MinTasksInstancesNumber
        # CloudwatchLogKinesisStreamArn: !Ref LogsKinesisSourceStreamArn
        TaskRoleManagedPolicyArn: !Ref PnSsManagedPolicy
        # HealthCheckPath: 
  
  PnSsManagedPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: 'String'
      ManagedPolicyName: !Ref PnSsManagedPolicyName
      PolicyDocument: 
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - 'dynamodb:*GetItem'
              - 'dynamodb:Query'
              - 'dynamodb:Describe*'
              - 'dynamodb:Scan'
              - 'dynamodb:List*'
              - 'dynamodb:DeleteItem'
              - 'dynamodb:Batch*'
              - 'dynamodb:PartiQL*'
              - 'dynamodb:Update*'
              - 'dynamodb:Put*'
              - 'dynamodb:GetRecords'
              - 'dynamodb:GetShardIterator'
            Resource:
              - !Sub '${PnSsTableArnAnagraficaClient}'
              - !Sub '${PnSsTableArnTipologieDocumenti}'
              - !Sub '${PnSsTableArnDocumenti}'
              - !Sub '${PnSsTableDocumentiStreamArn}'
          - Sid: 'FullAccesStreamMetadataTable'
            Effect: Allow
            Action:
              - 'dynamodb:*'
            Resource:
              - !Join [ '', [ !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/' , '*', !Ref PnSsTableDocumentiStreamMetadatiTable , '*']]
          - Sid: 'CloudWatchPutMetricData'
            Effect: Allow
            Action:
              - 'cloudwatch:PutMetricData'
            Resource:
              - '*'
          - Effect: Allow
            Action:
              - 's3:List*'
              - 's3:GetBucket*'
              - 's3:GetObject*'
              - 's3:*MultipartUpload*'
              - 's3:*LifecycleConfiguration'
              - 's3:*Replication*'
              - 's3:Replicate*'
              - 's3:PutBucket*'
              - 's3:PutObject*'
              - 's3:RestoreObject'
            Resource:
              - !Sub '${PnSsBucketArn}'
              - !Join [ '', [ !Sub '${PnSsBucketArn}' , '/*']]
              - !Sub '${PnSsStagingBucketArn}'
              - !Join [ '', [ !Sub '${PnSsStagingBucketArn}' , '/*']]
          - Effect: Allow
            Action:
              - 'sqs:ReceiveMessage'
              - 'sqs:DeleteMessage'
              - 'sqs:PurgeQueue'
              - 'sqs:Get*'
              - 'sqs:List*'
              - 'sqs:SendMessage'
            Resource:
              - !Sub '${PnSsQueueArnStagingBucket}'
          - Effect: Allow
            Sid: 'ReadFromSecretsManagerFirmaPEC'
            Action:
              - 'secretsmanager:DescribeSecret'
              - 'secretsmanager:GetSecretValue'
            Resource:
              - !Join [ '', [ !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:' , !Ref PnSsIdentityTimemark , '*']]
              - !Join [ '', [ !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:' , !Ref PnSsIdentitySignature , '*']]
          - Effect: Allow
            Action:
              - 'kms:*'
            Resource:
              - '*'
          - Sid: 'AllowPutEventsDisponibilita'
            Effect: Allow
            Action:
              - 'events:PutEvents'
              - 'events:DescribeEventBus'
            Resource:
              - !Sub '${PnSsEventBusArnExternalNotification}'

  #####    Staging Bucket Events Rule    #####
  PnSsEventRuleStagingBucket:
    Type: AWS::Events::Rule
    Properties:
      Description: 'Rule catching object creation events in SS staging bucket'
      EventPattern:   
        source: 
          - 'aws.s3' 
        account: 
          - !Sub ${AWS::AccountId}
        region:
          - !Sub ${AWS::Region}
        detail-type: 
          - 'Object Created'
        detail:
          bucket:
            name: 
              - !Ref PnSsStagingBucketName
        resources:
          - !Ref PnSsStagingBucketArn
      State: 'ENABLED'
      Targets:
        - Arn: !Ref PnSsQueueArnStagingBucket
          Id: "SQSTargetForStagingBucket"

  #####    External notifications    #####
  PnSsRoleExternalNotifications:
    Type: AWS::IAM::Role
    Properties:
      Description: 'Role for forwarding Events to PnCoreTargetEventBus'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Action:
              - 'sts:AssumeRole'
            Principal:
              Service: 
                - 'events.amazonaws.com'
      Policies:
        - PolicyName: 'PutEventsInlinePolicy'
          PolicyDocument: 
            Version: '2012-10-17'
            Statement:
              - Sid: 'PutEventsOnTargetAccount'
                Effect: Allow
                Action:
                  - 'events:PutEvents'
                Resource:
                  - !Ref PnCoreTargetEventBus
      # RoleName: PnSsRole

  PnSsQueuePolicyExternalNotifications:
    Type: AWS::SQS::QueuePolicy
    Properties: 
      Queues: 
        - !Ref PnSsQueueUrlEventsDLQueuePnCoreTargetEventBus
      PolicyDocument: 
        Statement: 
          - Sid: 'AllowAccessSameAccount'
            Action: 
              - "SQS:*"
            Effect: "Allow"
            Resource: !Ref PnSsQueueArnEventsDLQueuePnCoreTargetEventBus
            Principal: 
              AWS: !Sub ${AWS::AccountId}
          - Sid: 'AllowPutEventsFromEventRule'
            Action: 
              - "sqs:SendMessage"
            Effect: "Allow"
            Resource: !Ref PnSsQueueArnEventsDLQueuePnCoreTargetEventBus
            Principal: 
              Service:
              - 'events.amazonaws.com'
            Condition: 
              ArnEquals:
                aws:SourceArn: !GetAtt PnSsEventRuleExternalNotifications.Arn

  PnSsEventRuleExternalNotifications:
    Type: AWS::Events::Rule
    Properties:
      EventBusName: !Ref PnSsEventBusNameExternalNotification
      Description: 'Rule forwarding events to Pn Core EventBus'
      EventPattern:
        source: 
          - "GESTORE DISPONIBILITA"
        account: 
          - !Sub ${AWS::AccountId}
        region: 
          - !Sub ${AWS::Region}
      State: 'ENABLED'
      Targets:
        - Arn: !Ref PnCoreTargetEventBus
          Id: 'PnSsExternalNotificationTarget'
          RoleArn: !GetAtt PnSsRoleExternalNotifications.Arn
          DeadLetterConfig:
            Arn: !Ref PnSsQueueArnEventsDLQueuePnCoreTargetEventBus

  #####    Metrics and Alarms  -  Microservice ##### 
  SafeStorageMicroserviceAlarm:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: !Sub "${TemplateBucketBaseUrl}/fragments/microservice-alarm.yaml"
      Parameters:
        MicroserviceName: !Sub '${ProjectName}-safe-storage' # Must be identical to the one in the ecs-service stack
        EvaluationPeriod: '10'
        DatapointsToAlarm: '1'
        Threshold: '1'

  SafeStorageMicroserviceAlarmDashboard:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: !Sub "${TemplateBucketBaseUrl}/fragments/microservice-cloudwatch-dashboard.yaml"
      Parameters:
        DashboardName: !Sub '${ProjectName}-safe-storage'
        AlarmArns: 
          !Join
          - ','
          - - !GetAtt SafeStorageMicroserviceAlarm.Outputs.MicroserviceAlarmArn
            - !GetAtt SafeStorageMicroservice.Outputs.FatalLogsMetricAlarmArn
            - !Ref PnSsAlarmArnQueueStagingBucket
            - !Ref PnSsAlarmArnDLQueueStagingBucket
            - !Ref PnSsAlarmArnQueueGestoreBucketInvokeErrors
            - !Ref PnSsAlarmArnDLQueueGestoreBucketInvokeErrors
            - !Ref PnSsAlarmArnQueueGestoreBucketInvoke
            - !Ref PnSsAlarmArnDLQueueGestoreBucketInvoke
            - !Ref PnSsAlarmArnEventsDLQueuePnCoreTargetEventBus
            # - !GetAtt SafeStorageMicroservice.Outputs.AutoScalingAlarmArn
        DynamoDBTableNames:
          !Join
          - ','
          - - !Ref PnSsTableNameAnagraficaClient
            - !Ref PnSsTableNameTipologieDocumenti
            - !Ref PnSsTableNameDocumenti
        # RestApiStageArns:
        # RestApiNames:
        QueueArns:
          !Join
          - ','
          - - !Ref PnSsQueueArnStagingBucket
            - !Ref PnSsQueueArnGestoreBucketInvoke
            - !Ref PnSsQueueArnGestoreBucketInvokeErrors
            - !Ref PnSsQueueArnEventsDLQueuePnCoreTargetEventBus
        LambdaArns: !GetAtt PnSsGestoreBucket.Arn
        # KinesisDataArns:
        # KinesisFirehoseArns:
        EventRuleArns: !GetAtt PnSsEventRuleStagingBucket.Arn
          # !Join
          # - ','
          # - - !Ref PnSsEventRuleArnStagingBucket
        BucketNames:
          !Join
          - ','
          - - !Ref PnSsBucketName
            - !Ref PnSsStagingBucketName

  #####    Bucket + Queue Policies   ##### 
  PnSsStagingBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Sub ${PnSsStagingBucketName}
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 's3:*'
            Effect: Allow
            Resource: !Join [ '', [ !Sub '${PnSsStagingBucketArn}' , '/*']]
            Principal:  
              AWS: 
                - !Join [ '', [ !Sub 'arn:aws:iam::${AWS::AccountId}:role/' , !GetAtt SafeStorageMicroservice.Outputs.TaskRoleName]] 

  PnSsQueuePolicyStagingBucket:
    Type: AWS::SQS::QueuePolicy
    Properties: 
      Queues: 
        - !Sub '${PnSsQueueUrlStagingBucket}'
      PolicyDocument:
        Version: '2012-10-17'
        Statement: 
          - Action: 
              - 'SQS:*'
            Effect: "Allow"
            Resource: !Sub ${PnSsQueueArnStagingBucket}
            Principal:  
              AWS: 
                - !Join [ '', [ !Sub 'arn:aws:iam::${AWS::AccountId}:role/' , !GetAtt SafeStorageMicroservice.Outputs.TaskRoleName]]
              Service:
                - 'events.amazonaws.com'
 

  #####   Cloud Trail  +  Logging   #####
  SafeStorageCloudTrail:
    Condition: HasCloudTrailLogsBucketName
    Type: AWS::CloudTrail::Trail
    Properties:
      TrailName: !Ref TrailName
      IsMultiRegionTrail: false
      IsOrganizationTrail: false
      EnableLogFileValidation: false
      EventSelectors:
        - DataResources:
            - Type: AWS::S3::Object
              Values:
                - !Sub "arn:${AWS::Partition}:s3:::${PnSsBucketName}/"  
          IncludeManagementEvents: false
          ReadWriteType: All
      S3BucketName: !Ref SafeStorageFileAccessLogsBucketName
      S3KeyPrefix: !Ref SafeStorageFileAccessLogsBucketPathPrefix
      IsLogging: true
  
#####    Gestore Bucket e risorse a lui afferenti    #####
  PnSsQueuePolicyGestoreBucketInvokeErrors:
      Type: AWS::SQS::QueuePolicy
      Properties: 
        Queues: 
          - !Sub '${PnSsQueueUrlGestoreBucketInvokeErrors}'
        PolicyDocument:
          Version: '2012-10-17'
          Statement: 
            - Action: 
                - 'SQS:*'
              Effect: "Allow"
              Resource: !Sub ${PnSsQueueArnGestoreBucketInvokeErrors}
              Principal:  
                AWS: 
                  - !Join [ '', [ !Sub 'arn:aws:iam::${AWS::AccountId}:role/' , !Ref PnSsGestoreBucketRole]]
  
  PnSsGestoreBucketRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join [ '', [!Sub '${PnSsGestoreBucketLambdaName}', '-role-name']]
      Description: 'Ruolo della Lambda che implementa la funzionalità del Gestore Bucket'
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action:
          - 'sts:AssumeRole'
      Policies:
        - PolicyName: 'PnSsGestoreBucketInlinePolicy'
          PolicyDocument: 
            Version: '2012-10-17'
            Statement: 
              - Sid: 'GeneralBucketPolicy'
                Effect: 'Allow'
                Action: 
                  - 's3:List*'
                  - 's3:GetBucket*'
                  - 's3:Put*'
                  - 's3:Describe*'
                  - 's3:Get*'
                  - 's3:*MultipartUpload*'
                  - 's3:*Tag*'
                Resource:
                  - !Sub '${PnSsBucketArn}'
                  - !Join [ '', [ !Sub '${PnSsBucketArn}' , '/*']]
              - Sid: 'QueueInvokeErrorsPolicyProducer'
                Effect: 'Allow'
                Action: 
                  - 'sqs:SendMessage'
                Resource:
                  - !Ref PnSsQueueArnGestoreBucketInvokeErrors
              - Sid: 'GetInvokeSQS'
                Effect: 'Allow'
                Action: 
                  - 'sqs:ReceiveMessage'
                  - 'sqs:DeleteMessage'
                  - 'sqs:Get*'
                  - 'sqs:List*'
                  - 'sqs:SendMessage'
                Resource:
                  - !Ref PnSsQueueArnGestoreBucketInvoke
              - Sid: 'DefaultKMSGrantRead'
                Effect: 'Allow'
                Action: 
                  - 'kms:GenerateDataKey'
                  - 'kms:Decrypt'
                Resource: '*'
                Condition:
                  StringLike:
                    kms:RequestAlias: 'alias/aws/sqs'

  PnSsSecurityGroupSafeStorage:
    Type: AWS::EC2::SecurityGroup
    Properties: 
      GroupDescription: 'Security Group per la Lambda Gestore Bucket (SafeStorage)'
      GroupName: !Ref PnSsSecurityGroupNameSafeStorage
      SecurityGroupIngress: 
        - IpProtocol: -1
          SourceSecurityGroupId: !Ref PnVPCDefaultSecurityGroup
      VpcId: !Ref VpcId

  PnSsGestoreBucketInputQueue:
    Type: AWS::Lambda::EventSourceMapping
    Properties: 
      BatchSize: 10 # 10 is default
      Enabled: True
      EventSourceArn: !Ref PnSsQueueArnGestoreBucketInvoke
      FunctionName: !Ref PnSsGestoreBucket
      FunctionResponseTypes: 
        - ReportBatchItemFailures
      MaximumBatchingWindowInSeconds: 0 #default value
      ScalingConfig: 
        MaximumConcurrency: !Ref PnSsGestoreBucketReservedConcurrentExecutions

  PnSsGestoreBucket:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Ref PnSsGestoreBucketLambdaName
      Description: 'Pn SafeStorage Gestore Bucket'
      Handler: index.handler
      MemorySize: 1024
      ReservedConcurrentExecutions: !Ref PnSsGestoreBucketReservedConcurrentExecutions
      Runtime: nodejs16.x
      Role: !GetAtt PnSsGestoreBucketRole.Arn
      Timeout: 240
      DeadLetterConfig: 
        TargetArn: !Ref PnSsQueueArnGestoreBucketInvokeErrors
      VpcConfig:
        SubnetIds:
          - !Select [ 0, !Split [ ",", !Ref SubnetsIds ] ]
          - !Select [ 1, !Split [ ",", !Ref SubnetsIds ] ]
          - !Select [ 2, !Split [ ",", !Ref SubnetsIds ] ]
        SecurityGroupIds:
          - !GetAtt PnSsSecurityGroupSafeStorage.GroupId
      Environment:
        Variables:
          PnSsHostname: !Ref ApplicationLoadBalancerDomain
          PnSsGestoreRepositoryPort: !Ref PnSsGestoreRepositoryPort
          PnSsGestoreRepositoryProtocol: !Ref PnSsGestoreRepositoryProtocol
          PnSsGestoreRepositoryPathGetDocument: !Ref PnSsGestoreRepositoryPathGetDocument
          PnSsGestoreRepositoryPathPatchDocument: !Ref PnSsGestoreRepositoryPathPatchDocument
          PnSsStagingBucketName: !Ref PnSsStagingBucketName

      Code:
        ZipFile: |
          "use strict";
         
          const http = require(process.env.PnSsGestoreRepositoryProtocol);
          const AWS = require("aws-sdk");
          const crypto = require("crypto");
         
          const HOSTNAME = process.env.PnSsHostname;
          const PORT = process.env.PnSsGestoreRepositoryPort;
          const PATHGET = process.env.PnSsGestoreRepositoryPathGetDocument;
          const PATHPATCH = process.env.PnSsGestoreRepositoryPathPatchDocument;
          const STAGINGBUCKET = process.env.PnSsStagingBucketName;
         
          exports.handler = async (event) => {
            const s3 = new AWS.S3();
            const batchItemFailures =[];
            console.log(JSON.stringify(event));
         
            await Promise.allSettled(
              event.Records.map(async (record) => {
                const bodyData = JSON.parse(record.body);
         
                console.log("Processing " + record.messageId);
         
                let jsonDocument = {
                  documentKey: "",
                  documentState: "",
                };
         
                let bucketName;
                console.log("Buket Name: " + bodyData.Records[0].s3.bucket.name);
                console.log("Object Key: " + bodyData.Records[0].s3.object.key);
                console.log("Object Size: " + bodyData.Records[0].s3.object.size);
                let params = {
                  Bucket: "",
                  Key: "",
                };
                bucketName = bodyData.Records[0].s3.bucket.name;
                jsonDocument.documentKey = bodyData.Records[0].s3.object.key;
                switch (bodyData.Records[0].eventName) {
                  case "ObjectCreated:*":
                    break;
                  case "ObjectCreated:Put":
                    if (bucketName === STAGINGBUCKET) {
                      jsonDocument.documentState = "staged";
                    } else {
                      jsonDocument.contentLenght = bodyData.Records[0].s3.object.size;
                      jsonDocument.documentState = "available";
                      params.Bucket = bucketName;
                      params.Key = jsonDocument.documentKey;
                      try {
                        const { Body } = await s3
                          .getObject(params)
                          .promise();
                        console.log(Body);
                        const doc = await getDocumentFromDB(jsonDocument.documentKey);
          
                        console.log(doc.document);
                        console.log(doc.document.documentType.checksum);
                        console.log(JSON.stringify(doc.document.documentType.checksum));
          
                        jsonDocument.checkSum = crypto
                          .createHash(doc.document.documentType.checksum)
                          .update(Body)
                          .digest("base64");
                      } catch (error) {
                        console.log(error);
                        const messageError = `Errore nella lavorazione dell'oggetto ${jsonDocument.documentKey} dal bucket ${bucketName}. Verificare che l'oggetto esiste nel bucket o sul database Dynamo.`;
                        console.log(messageError);
                        failedMessageIds.push(record.messageId);
                        return;
                        //throw new Error(messageError);
                      }
                    }
                    console.log(jsonDocument);
                    break;
                  case "ObjectCreated:Copy":
                    jsonDocument.documentState = "available";
                    break;
                  case "ObjectRestore:Completed":
                    jsonDocument.documentState = "available";
                    break;
                  case "LifecycleTransition":
                    jsonDocument.documentState = "freezed";
                    break;
                  case "ObjectRestore:Delete":
                    jsonDocument.documentState = "freezed";
                    break;
                  case "LifecycleExpiration:DeleteMarkerCreated":
                    jsonDocument.documentState = "deleted";
                    break;
                  case "ObjectRemoved:DeleteMarkerCreated":
                    jsonDocument.documentState = "deleted";
                    break;
                  default:
                    return;
                }
                await updateDynamo(jsonDocument).then(
                  function(data) {
                    console.log("############## EXIT  ####################");
                    return;
                  },
                  function(error) {
                    const retMessgeError = "Errore nella patch su DynamoDB - " + error;
                    console.log(retMessgeError);
                    batchItemFailures.push({itemIdentifier: record.messageId});
                    return;
                  }
                );
              })
            );
            console.log("FINE LAVORAZIONE EVENTO");
            return { batchItemFailures };
          };
          function getDocumentFromDB(docKey) {
            const options = {
              method: "GET",
              hostname: HOSTNAME,
              port: PORT,
              path: PATHGET + "/" + docKey,
              headers: {
                "Content-Type": "application/json",
              },
            };
            return new Promise((resolve, reject) => {
              const req = http.request(options, (res) => {
                let responseBody = "";
          
                res.on("data", (chunk) => {
                  responseBody += chunk;
                });
          
                res.on("end", () => {
                  resolve(JSON.parse(responseBody));
                });
              });
          
              req.on("error", (err) => {
                console.error(err);
                reject(err);
              });
              req.end();
            });
          }
          function updateDynamo(data) {
            const options = {
              method: "PATCH",
              hostname: HOSTNAME,
              port: PORT,
              path: PATHPATCH + "/" + data.documentKey,
              headers: {
                "Content-Type": "application/json",
              },
            };
            return new Promise((resolve, reject) => {
              const req = http.request(options, (res) => {
                let responseBody = "";
                res.on("data", (chunk) => {
                  responseBody += chunk;
                });
                res.on("end", () => {
                  console.log(res.statusCode + " - " + responseBody);
                  switch (res.statusCode) {
                    case 200:
                      resolve(JSON.parse(responseBody));
                      break;
                    default:
                      reject(res.statusCode + " - " + data.documentKey);
                      break;
                  }
                });
              });
              req.on("error", (err) => {
                console.error(err);
                reject(err);
              });
              req.write(JSON.stringify(data));
              req.end();
            });
          }
