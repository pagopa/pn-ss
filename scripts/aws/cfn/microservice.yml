AWSTemplateFormatVersion: 2010-09-09
Description: 'Example microservice deploy'

Parameters:
  ProjectName:
    Type: String
    Description: 'Usually pn can be pnXYZ where XYZ are the feature number, useful to create
      experimental environments without crash official development environment'

  AlarmSNSTopicArn:
    Type: String
    Description: ARN of alarm topic

  # WebApiDnsName:
  #   Type: String
  #   Description: 'The DNS name used for WEB rest API.'
  
  # CorsAllowedDomains:
  #   Type: String
  #   Description: 'Comma separated list of domains allowed to make cross origin request'

  ContainerImageUri:
    Type: String
    Description: 'Exact container image URI with full repository and image digest'

  MicroserviceNumber:
    Type: Number
    Description: 'Disambiguation useful for load balancer rules'

  TemplateBucketBaseUrl:
    Type: String
    Description: 'The S3 bucket from which to fetch the templates used by this stack.'

  ECSClusterName:
    Type: String
    Description: 'The name of the ECS cluster where the microservice is going to be deployed'

  SubnetsIds:
    Type: String
    Description: 'subnets ids comma separated list. Where to deploy the microservice'

  VpcId:
    Type: String
    Description: 'VpcId where the microservice is going to be deployed'
  
  EcsDefaultSecurityGroup:
    Type: String
    Description: 'Default security group required by infrastructure'

  ApplicationLoadBalancerListenerArn:
    Type: String
    Description: 'Load balancer listener where HTTP endpoints is going to be registered'

  ApplicationLoadBalancerDomain:
    Type: String
    Description: 'Base URL of the load balancer where the service is going to be reachable'

  NetworkLoadBalancerLink:
    Type: String
    Description: 'network load balancer link for API-GW'
  
  # LogsKinesisSourceStreamArn:
  #   Type: String
  #   Description: 'Kinesis stream that receive logs'
  
  Version:
    Type: String
    Description: 'keep track of used projects commitIds'

  PnSsTableNameAnagraficaClient:
    Type: String
    Description: 'Nome della tabella SS Anagrafica Client'

  PnSsTableArnAnagraficaClient:
    Type: String
    Description: 'ARN della Tabella DynamoDB relativa alla Macchina a Stati'
  
  PnSsTableNameTipologieDocumenti:
    Type: String
    Description: 'Nome della tabella SS Tipologie Documenti'

  PnSsTableArnTipologieDocumenti:
    Type: String
    Description: 'ARN della tabella SS Tipologie Documenti'
  
  PnSsTableNameDocumenti:
    Type: String
    Description: 'Nome tabella SS Documenti'

  PnSsTableArnDocumenti:
    Type: String
    Description: 'ARN della tabella SS Documenti'

  PnSsTableDocumentiStreamArn:
    Type: String
    Description: 'ARN dello stream relativo alla tabella SS Documenti'

  PnSsBucketName:
    Type: String
    Description: 'Nome del Bucket SS'

  PnSsBucketArn:
    Type: String
    Description: 'ARN del Bucket SS'
  
  PnSsStagingBucketName:
    Type: String
    Description: 'Nome Bucket SS Staging'

  PnSsStagingBucketArn:
    Type: String
    Description: 'ARN Bucket SS Staging'

  PnSsQueueNameStagingBucket:
    Type: String
    Description: 'Nome coda per notifiche SS Staging Bucket'

  PnSsQueueArnStagingBucket:
    Type: String
    Description: 'ARN coda per notifiche SS Staging Bucket'

  PnSsQueueUrlStagingBucket:
    Type: String
    Description: 'URL coda per notifiche SS Staging Bucket'

  PnSsDLQueueNameStagingBucket:
    Type: String
    Description: 'Nome coda DLQ per notifiche SS Staging Bucket'
  
  PnSsManagedPolicyName:
    Type: String
    Description: 'Nome della managed policy associata alla state machine'
    Default: 'PnSsManagedPolicyName'

  PnSsEventBusNameExternalNotification:
    Type: String
    Description: 'Nome event bus per pubblicare eventi di Gestore Disponibilita'

  PnSsEventBusArnExternalNotification:
    Type: String
    Description: 'Arn event bus per pubblicare eventi di Gestore Disponibilita'

  PnSsQueueNameNotificheExt1:
    Type: String
    Description: 'Nome coda per catturare eventi generati da Gestore Disponibilita'

  PnSsQueueArnNotificheExt1:
    Type: String
    Description: 'ARN coda per catturare eventi generati da Gestore Disponibilita'

  PnSsQueueUrlNotificheExt1:
    Type: String
    Description: 'URL coda per catturare eventi generati da Gestore Disponibilita'

  PnSsDLQueueNameNotificheExt1:
    Type: String
    Description: 'Nome coda per catturare eventi generati da Gestore Disponibilita'

  PnSsDLQueueArnNotificheExt1:
    Type: String
    Description: 'ARN coda per catturare eventi generati da Gestore Disponibilita'

  PnSsDLQueueUrlNotificheExt1:
    Type: String
    Description: 'URL coda per catturare eventi generati da Gestore Disponibilita'

  PnSsGestoreBucketLambdaName:
    Type: String
    Description: 'Nome della Lambda function che implementa la funzionalità del Gestore Bucket'

  PresignedUrlMinutesLifespan:
    Type: String
    Description: 'Minuti di validità dei pre-signed url prima di scadere'

  PnEcIdentityTimemark:
    Type: String
    Description: 'Secret ID for Identity Timemark'

  PnEcIdentitySignature:
    Type: String
    Description: 'Secret ID for Identity Signature'

  PnVPCSubnetId1:
    Type: String
    Description: 'VPC Subnet ID 1 out of 3'

  PnVPCSubnetId2:
    Type: String
    Description: 'VPC Subnet ID 2 out of 3'

  PnVPCSubnetId3:
    Type: String
    Description: 'VPC Subnet ID 3 out of 3'

  PnVPCDefaultSecurityGroup:
    Type: String
    Description: 'VPC Subnet ID 3 out of 3'

  PnSsGestoreRepositoryProtocol:
    Type: String
    Description: 'Protocol for connecting to pn-ss Gestore Respository'

  PnSsGestoreRepositoryPort:
    Type: String
    Description: 'Port for connecting to pn-ss Gestore Respository'

  PnSsGestoreRepositoryPathGetDocument:
    Type: String
    Description: 'Path for GetDocument towards pn-ss Gestore Respository'

  PnSsGestoreRepositoryPathPatchDocument:
    Type: String
    Description: 'Path for PatchDocument towards pn-ss Gestore Respository'
  
  PnSsUriBuilderstayHotTime:
    Type: String
    Description: 'Days parameter for restoring of Staging Buckets objects in Glacier archive'

  PnSsTableDocumentiStreamMetadatiTable:
    Type: String
    Description: 'Name of the DynamoDB Stream's metadata table for the source table PnSsDocumenti'
  

Resources:

  # PN-TemplateBeMs microservice
  SafeStorageMicroservice:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: !Sub '${TemplateBucketBaseUrl}/fragments/ecs-service.yaml'
      Parameters:
        MicroServiceUniqueName: !Sub '${ProjectName}-safe-storage'
        CpuValue: 2048
        MemoryAmount: 6GB
        AlarmSNSTopicArn: !Ref AlarmSNSTopicArn
        ContainerImageURI: !Sub '${ContainerImageUri}'
        ContainerEnvEntry1: !Sub 'AWS_REGIONCODE=${AWS::Region}'
        ContainerEnvEntry2: !Sub 'PnSsEventBusNameExternalNotification=${PnSsEventBusNameExternalNotification}'
        ContainerEnvEntry3: !Sub 'PnSsBucketName=${PnSsBucketName}'
        ContainerEnvEntry4: !Sub 'PnSsBucketArn=${PnSsBucketArn}'
        ContainerEnvEntry5: !Sub 'PnSsStagingBucketName=${PnSsStagingBucketName}'
        ContainerEnvEntry6: !Sub 'PnSsStagingBucketArn=${PnSsStagingBucketArn}'
        ContainerEnvEntry7: !Sub 'PnSsTableNameAnagraficaClient=${PnSsTableNameAnagraficaClient}'
        ContainerEnvEntry8: !Sub 'PnSsTableNameTipologieDocumenti=${PnSsTableNameTipologieDocumenti}'
        ContainerEnvEntry9: !Sub 'PnSsTableNameDocumenti=${PnSsTableNameDocumenti}'
        ContainerEnvEntry10: !Sub 'PnSsTableDocumentiStreamArn=${PnSsTableDocumentiStreamArn}'
        ContainerEnvEntry11: !Sub 'PnSsTableDocumentiStreamMetadatiTable=${PnSsTableDocumentiStreamMetadatiTable}'
        ContainerEnvEntry12: !Sub 'PnSsQueueNameStagingBucket=${PnSsQueueNameStagingBucket}'
        ContainerEnvEntry20: !Sub 'pst=${PresignedUrlMinutesLifespan}'
        ContainerEnvEntry21: !Sub 'stayHotTime=${PnSsUriBuilderstayHotTime}'
        ContainerEnvEntry40: !Sub 'StateMachineBaseUrl=http://${ApplicationLoadBalancerDomain}:8080'
        ContainerEnvEntry41: !Sub 'InternalBaseUrl=http://${ApplicationLoadBalancerDomain}:8080'
        MappedPaths: '/safestorage/*,/safe-storage/*'
        ECSClusterName: !Ref ECSClusterName
        Subnets: !Ref SubnetsIds
        VpcId: !Ref VpcId
        EcsDefaultSecurityGroup: !Ref EcsDefaultSecurityGroup
        LoadBalancerListenerArn: !Ref ApplicationLoadBalancerListenerArn
        LoadbalancerRulePriority: !Ref MicroserviceNumber
        # CloudwatchLogKinesisStreamArn: !Ref LogsKinesisSourceStreamArn
        TaskRoleManagedPolicyArn: !Ref PnSsManagedPolicy
        # HealthCheckPath: 
  
  PnSsManagedPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: 'String'
      ManagedPolicyName: !Ref PnSsManagedPolicyName
      PolicyDocument: 
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - 'dynamodb:*GetItem'
              - 'dynamodb:Query'
              - 'dynamodb:Describe*'
              - 'dynamodb:Scan'
              - 'dynamodb:List*'
              - 'dynamodb:DeleteItem'
              - 'dynamodb:Batch*'
              - 'dynamodb:PartiQL*'
              - 'dynamodb:Update*'
              - 'dynamodb:Put*'
              - 'dynamodb:GetRecords'
              - 'dynamodb:GetShardIterator'
            Resource:
              - !Sub '${PnSsTableArnAnagraficaClient}'
              - !Sub '${PnSsTableArnTipologieDocumenti}'
              - !Sub '${PnSsTableArnDocumenti}'
              - !Sub '${PnSsTableDocumentiStreamArn}'
              - !Join [ '', [ !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/' , '*', !Ref PnSsTableDocumentiStreamMetadatiTable , '*']]
          - Effect: Allow
            Action:
              - 's3:List*'
              - 's3:GetBucket*'
              - 's3:GetObject*'
              - 's3:*MultipartUpload*'
              - 's3:*LifecycleConfiguration'
              - 's3:*Replication*'
              - 's3:Replicate*'
              - 's3:PutBucket*'
              - 's3:PutObject*'
              - 's3:RestoreObject'
            Resource:
              - !Sub '${PnSsBucketArn}'
              - !Join [ '', [ !Sub '${PnSsBucketArn}' , '/*']]
              - !Sub '${PnSsStagingBucketArn}'
              - !Join [ '', [ !Sub '${PnSsStagingBucketArn}' , '/*']]
          - Effect: Allow
            Action:
              - 'sqs:ReceiveMessage'
              - 'sqs:DeleteMessage'
              - 'sqs:PurgeQueue'
              - 'sqs:Get*'
              - 'sqs:List*'
            Resource:
              - !Sub '${PnSsQueueArnStagingBucket}'
              - !Sub '${PnSsQueueArnNotificheExt1}'
          - Effect: Allow
            Sid: 'ReadFromSecretsManagerFirmaPEC'
            Action:
              - 'secrets:DescribeSecret'
              - 'secrets:GetSecretValue'
            Resource:
              - !Join [ '', [ !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:' , !Ref PnEcIdentityTimemark , '*']]
              - !Join [ '', [ !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:' , !Ref PnEcIdentitySignature , '*']]
          - Effect: Allow
            Action:
              - 'kms:*'
            Resource:
              - '*'
          - Sid: 'AllowPutEventsDisponibilita'
            Effect: Allow
            Action:
              - 'events:PutEvents'
              - 'events:DescribeEventBus'
            Resource:
              - !Sub '${PnSsEventBusArnExternalNotification}'

  PnSsStagingBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Sub ${PnSsStagingBucketName}
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 's3:*'
            Effect: Allow
            Resource: !Join [ '', [ !Sub '${PnSsStagingBucketArn}' , '/*']]
            Principal:  
              AWS: 
                - !Join [ '', [ !Sub 'arn:aws:iam::${AWS::AccountId}:role/' , !GetAtt SafeStorageMicroservice.Outputs.TaskRoleName]] 

  PnSsQueuePolicyStagingBucket:
    Type: AWS::SQS::QueuePolicy
    Properties: 
      Queues: 
        - !Sub '${PnSsQueueUrlStagingBucket}'
      PolicyDocument:
        Version: '2012-10-17'
        Statement: 
          - Action: 
              - 'SQS:*'
            Effect: "Allow"
            Resource: !Sub ${PnSsQueueArnStagingBucket}
            Principal:  
              AWS: 
                - !Join [ '', [ !Sub 'arn:aws:iam::${AWS::AccountId}:role/' , !GetAtt SafeStorageMicroservice.Outputs.TaskRoleName]]
              Service:
                - 'events.amazonaws.com'
           
  PnSsGestoreBucketRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join [ '', [!Sub 'PnSsGestoreBucketLambdaName', '-role-name']]
      Description: 'Ruolo della Lambda che implementa la funzionalità del Gestore Bucket'
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action:
          - 'sts:AssumeRole'
      Policies:
        - PolicyName: 'PnSsGestoreBucketInlinePolicy'
          PolicyDocument: 
            Version: '2012-10-17'
            Statement: 
              - Sid: 'GeneralBucketPolicy'
                Effect: 'Allow'
                Action: 
                  - 's3:List*'
                  - 's3:GetBucket*'
                  - 's3:Put*'
                  - 's3:Describe*'
                  - 's3:Get*'
                  - 's3:*MultipartUpload*'
                  - 's3:*Tag*'
                Resource:
                  - !Sub '${PnSsBucketArn}'
                  - !Join [ '', [ !Sub '${PnSsBucketArn}' , '/*']]

  PnSsGestoreBucketHotNotificationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt PnSsGestoreBucket.Arn
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceAccount: !Ref 'AWS::AccountId'
      SourceArn: !Ref PnSsBucketArn

  PnSsGestoreBucketStagingNotificationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt PnSsGestoreBucket.Arn
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceAccount: !Ref 'AWS::AccountId'
      SourceArn: !Ref PnSsStagingBucketArn

  PnSsGestoreBucket:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Ref PnSsGestoreBucketLambdaName
      Description: 'Pn SafeStorage Gestore Bucket'
      Handler: index.handler
      MemorySize: 1024
      Runtime: nodejs16.x
      Role: !GetAtt PnSsGestoreBucketRole.Arn
      Timeout: 240
      VpcConfig:
        SubnetIds:
          - !Ref PnVPCSubnetId1
          - !Ref PnVPCSubnetId2
          - !Ref PnVPCSubnetId3
        SecurityGroupIds:
          - !Ref PnVPCDefaultSecurityGroup
      Environment:
        Variables:
          PnSsHostname: !Ref ApplicationLoadBalancerDomain
          PnSsGestoreRepositoryPort: !Ref PnSsGestoreRepositoryPort
          PnSsGestoreRepositoryProtocol: !Ref PnSsGestoreRepositoryProtocol
          PnSsGestoreRepositoryPathGetDocument: !Ref PnSsGestoreRepositoryPathGetDocument
          PnSsGestoreRepositoryPathPatchDocument: !Ref PnSsGestoreRepositoryPathPatchDocument
          PnSsStagingBucketName: !Ref PnSsStagingBucketName
      Code:
        ZipFile: |
          "use strict";

          const http = require(process.env.PnSsGestoreRepositoryProtocol);
          const AWS = require("aws-sdk");
          const crypto = require("crypto");

          const s3 = new AWS.S3();
          const HOSTNAME = process.env.PnSsHostname;
          const PORT = process.env.PnSsGestoreRepositoryPort;
          const PATHGET  = process.env.PnSsGestoreRepositoryPathGetDocument;
          const PATHPATCH = process.env.PnSsGestoreRepositoryPathPatchDocument;
          const STAGINGBUCKET = process.env.PnSsStagingBucketName;

          let jsonDocument = {
            documentKey: "",
            documentState: "",
          };
          exports.handler = async (event) => {
            console.log(JSON.stringify(event));
            let bucketName;
            console.log("Buket Name: " + event.Records[0].s3.bucket.name);
            console.log("Object Key: " + event.Records[0].s3.object.key);
            console.log("Object Size: " + event.Records[0].s3.object.size);
            let params = {
              Bucket: "",
              Key: "",
            };
            bucketName = event.Records[0].s3.bucket.name;
            jsonDocument.documentKey = event.Records[0].s3.object.key;
            switch (event.Records[0].eventName) {
              case "ObjectCreated:*":
                break;
              case "ObjectCreated:Put":
                if(bucketName === STAGINGBUCKET){
                  jsonDocument.documentState = "staged";
                }else{
                  jsonDocument.contentLenght = event.Records[0].s3.object.size;
                  jsonDocument.documentState = "available";
                  params.Bucket = bucketName;
                  params.Key = jsonDocument.documentKey;
                  const { Body } = await s3.getObject(params).promise();
                  console.log(Body);
                  const doc = await getDocumentFromDB(jsonDocument.documentKey);
                  console.log(doc);
                  console.log(doc.document);
                  console.log(doc.document.documentType.checksum);
                  console.log(JSON.stringify(doc.document.documentType.checksum));
                  jsonDocument.checkSum = crypto.createHash(doc.document.documentType.checksum).update(Body).digest("hex"); 
                }
                console.log(jsonDocument);
                break;
              case "ObjectCreated:Copy":
                jsonDocument.documentState = "available";
              break;
              case "ObjectRestore:Completed":
                jsonDocument.documentState = "available";
                break;
              case "LifecycleTransition":
                jsonDocument.documentState = "freezed";
                break;
              case "ObjectRestore:Delete":
                jsonDocument.documentState = "freezed";
                break;
              case "LifecycleExpiration:Delete":
                jsonDocument.documentState = "deleted";
                break;
              case "ObjectRemoved:Delete":
                jsonDocument.documentState = "deleted";
                break;
              default:
                const response = {
                  statusCode: 200,
                };
              return response;
            }
            const res = await updateDynamo(jsonDocument);
            console.log(res);
            console.log("############## EXIT  ####################");
            const response = {
              statusCode: 200,
            };
            return response;
          };
          function getDocumentFromDB(docKey) {
            const options = {
              method: "GET",
              hostname: HOSTNAME,
              port: PORT,
              path: PATHGET + "/" + docKey,
              headers: {
                "Content-Type": "application/json",
              }, 
            };
            return new Promise((resolve, reject) => {
              const req = http.request(options, (res) => {
                
                let responseBody = "";

                res.on("data", (chunk) => {
                  responseBody += chunk;
                });

                res.on("end", () => {
                  resolve(JSON.parse(responseBody));
                });
              });

              req.on("error", (err) => {
                console.error(err);
                reject(err);
              });
              req.end();
            });
          }
          function updateDynamo(data) {
            const options = {
              method: "PATCH",
              hostname: HOSTNAME,
              port: PORT,
              path: PATHPATCH + "/" + data.documentKey,
              headers: {
                "Content-Type": "application/json",
              }, 
            };
            return new Promise((resolve, reject) => {
              const req = http.request(options, (res) => {
                let responseBody = "";
                res.on("data", (chunk) => {
                  responseBody += chunk;
                });
                res.on("end", () => {
                  resolve(JSON.parse(responseBody));
                });
              });
              req.on("error", (err) => {
                console.error(err);
                reject(err);
              });
              req.write(JSON.stringify(data));
              req.end();
            });
          }
