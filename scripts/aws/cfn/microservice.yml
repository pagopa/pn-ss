AWSTemplateFormatVersion: 2010-09-09
Description: 'Example microservice deploy'

Parameters:
  ProjectName:
    Type: String
    Description: 'Usually pn can be pnXYZ where XYZ are the feature number, useful to create
      experimental environments without crash official development environment'

  AlarmSNSTopicArn:
    Type: String
    Description: ARN of alarm topic

  # WebApiDnsName:
  #   Type: String
  #   Description: 'The DNS name used for WEB rest API.'
  
  # CorsAllowedDomains:
  #   Type: String
  #   Description: 'Comma separated list of domains allowed to make cross origin request'

  ContainerImageUri:
    Type: String
    Description: 'Exact container image URI with full repository and image digest'

  MicroserviceNumber:
    Type: Number
    Description: 'Disambiguation useful for load balancer rules'

  TemplateBucketBaseUrl:
    Type: String
    Description: 'The S3 bucket from which to fetch the templates used by this stack.'

  ECSClusterName:
    Type: String
    Description: 'The name of the ECS cluster where the microservice is going to be deployed'

  SubnetsIds:
    Type: String
    Description: 'subnets ids comma separated list. Where to deploy the microservice'

  VpcId:
    Type: String
    Description: 'VpcId where the microservice is going to be deployed'
  
  EcsDefaultSecurityGroup:
    Type: String
    Description: 'Default security group required by infrastructure'
    Default: ""

  ApplicationLoadBalancerListenerArn:
    Type: String
    Description: 'Load balancer listener where HTTP endpoints is going to be registered'

  ApplicationLoadBalancerDomain:
    Type: String
    Description: 'Base URL of the load balancer where the service is going to be reachable'

  #NetworkLoadBalancerLink:
  #  Type: String
  #  Description: 'network load balancer link for API-GW'
  
  # LogsKinesisSourceStreamArn:
  #   Type: String
  #   Description: 'Kinesis stream that receive logs'
  
  Version:
    Type: String
    Description: 'keep track of used projects commitIds'

  PnSsTableNameAnagraficaClient:
    Type: String
    Description: 'Nome della tabella SS Anagrafica Client'

  PnSsTableArnAnagraficaClient:
    Type: String
    Description: 'ARN della Tabella DynamoDB relativa alla Macchina a Stati'
  
  PnSsTableNameTipologieDocumenti:
    Type: String
    Description: 'Nome della tabella SS Tipologie Documenti'

  PnSsTableArnTipologieDocumenti:
    Type: String
    Description: 'ARN della tabella SS Tipologie Documenti'
  
  PnSsTableNameDocumenti:
    Type: String
    Description: 'Nome tabella SS Documenti'

  PnSsTableArnDocumenti:
    Type: String
    Description: 'ARN della tabella SS Documenti'

  PnSsTableDocumentiStreamArn:
    Type: String
    Description: 'ARN dello stream relativo alla tabella SS Documenti'

  PnSsBucketName:
    Type: String
    Description: 'Nome del Bucket SS'

  PnSsBucketArn:
    Type: String
    Description: 'ARN del Bucket SS'
  
  PnSsStagingBucketName:
    Type: String
    Description: 'Nome Bucket SS Staging'

  PnSsStagingBucketArn:
    Type: String
    Description: 'ARN Bucket SS Staging'

  PnSsQueueNameStagingBucket:
    Type: String
    Description: 'Nome coda per notifiche SS Staging Bucket'

  PnSsQueueArnStagingBucket:
    Type: String
    Description: 'ARN coda per notifiche SS Staging Bucket'

  PnSsQueueUrlStagingBucket:
    Type: String
    Description: 'URL coda per notifiche SS Staging Bucket'

  PnSsDLQueueNameStagingBucket:
    Type: String
    Description: 'Nome coda DLQ per notifiche SS Staging Bucket'

  PnSsQueueNameGestoreBucketInvokeErrors:
    Type: String
    Description: 'Nome coda per pubblicazione errori del Gestore Bucket'

  PnSsQueueArnGestoreBucketInvokeErrors:
    Type: String
    Description: 'ARN coda per pubblicazione errori del Gestore Bucket'

  PnSsQueueUrlGestoreBucketInvokeErrors:
    Type: String
    Description: 'URL coda per pubblicazione errori del Gestore Bucket'

  PnSsDLQueueGestoreBucketInvokeErrors:
    Type: String
    Description: 'Nome coda DLQ per pubblicazione errori del Gestore Bucket'
  
  PnSsManagedPolicyName:
    Type: String
    Description: 'Nome della managed policy associata alla state machine'
    Default: 'PnSsManagedPolicyName'

  PnSsEventBusNameExternalNotification:
    Type: String
    Description: 'Nome event bus per pubblicare eventi di Gestore Disponibilita'

  PnSsEventBusArnExternalNotification:
    Type: String
    Description: 'Arn event bus per pubblicare eventi di Gestore Disponibilita'

  PnSsQueueNameNotificheExt1:
    Type: String
    Description: 'Nome coda per catturare eventi generati da Gestore Disponibilita'

  PnSsQueueArnNotificheExt1:
    Type: String
    Description: 'ARN coda per catturare eventi generati da Gestore Disponibilita'

  PnSsQueueUrlNotificheExt1:
    Type: String
    Description: 'URL coda per catturare eventi generati da Gestore Disponibilita'

  PnSsDLQueueNameNotificheExt1:
    Type: String
    Description: 'Nome coda per catturare eventi generati da Gestore Disponibilita'

  PnSsDLQueueArnNotificheExt1:
    Type: String
    Description: 'ARN coda per catturare eventi generati da Gestore Disponibilita'

  PnSsDLQueueUrlNotificheExt1:
    Type: String
    Description: 'URL coda per catturare eventi generati da Gestore Disponibilita'

  PnSsGestoreBucketLambdaName:
    Type: String
    Description: 'Nome della Lambda function che implementa la funzionalità del Gestore Bucket'

  PresignedUrlMinutesLifespan:
    Type: String
    Description: 'Minuti di validità dei pre-signed url prima della scadenza'

  PnEcIdentityTimemark:
    Type: String
    Description: 'Secret ID for Identity Timemark'

  PnEcIdentitySignature:
    Type: String
    Description: 'Secret ID for Identity Signature'

  PnVPCDefaultSecurityGroup:
    Type: String
    Description: 'VPC default Security Group'

  PnSsGestoreRepositoryProtocol:
    Type: String
    Description: 'Protocol for connecting to pn-ss Gestore Respository'

  PnSsGestoreRepositoryPort:
    Type: String
    Description: 'Port for connecting to pn-ss Gestore Respository'

  PnSsGestoreRepositoryPathGetDocument:
    Type: String
    Description: 'Path for GetDocument towards pn-ss Gestore Respository'

  PnSsGestoreRepositoryPathPatchDocument:
    Type: String
    Description: 'Path for PatchDocument towards pn-ss Gestore Respository'
  
  PnSsUriBuilderstayHotTime:
    Type: String
    Description: 'Days parameter for restoring of Staging Buckets objects in Glacier archive'

  PnSsTableDocumentiStreamMetadatiTable:
    Type: String
    Description: 'Name of the DynamoDB Stream s metadata table for the source table PnSsDocumenti'

  PnSsArubaCertId:
    Type: String
    Description: 'Aruba param CertId'

  PnSsArubaEnabledLog:
    Type: String
    Description: 'Aruba param EnabledLog'

  PnSsArubaSignWsdlUrl:
    Type: String
    Description: 'Aruba param SignWsdlUrl'
  
  PnSsArubaQname:
    Type: String
    Description: 'Aruba param Qname'

  PnSsArubaSignService:
    Type: String
    Description: 'Aruba param SignService'
  

Resources:

  # PN-TemplateBeMs microservice
  SafeStorageMicroservice:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: !Sub '${TemplateBucketBaseUrl}/fragments/ecs-service.yaml'
      Parameters:
        MicroServiceUniqueName: !Sub '${ProjectName}-safe-storage'
        CpuValue: 2048
        MemoryAmount: 6GB
        AlarmSNSTopicArn: !Ref AlarmSNSTopicArn
        ContainerImageURI: !Sub '${ContainerImageUri}'
        ContainerEnvEntry1: !Sub 'AWS_REGIONCODE=${AWS::Region}'
        ContainerEnvEntry2: !Sub 'PnSsEventBusNameExternalNotification=${PnSsEventBusNameExternalNotification}'
        ContainerEnvEntry3: !Sub 'PnSsBucketName=${PnSsBucketName}'
        ContainerEnvEntry4: !Sub 'PnSsBucketArn=${PnSsBucketArn}'
        ContainerEnvEntry5: !Sub 'PnSsStagingBucketName=${PnSsBucketName}'
        ContainerEnvEntry6: !Sub 'PnSsStagingBucketArn=${PnSsBucketArn}'
        ContainerEnvEntry7: !Sub 'PnSsTableNameAnagraficaClient=${PnSsTableNameAnagraficaClient}'
        ContainerEnvEntry8: !Sub 'PnSsTableNameTipologieDocumenti=${PnSsTableNameTipologieDocumenti}'
        ContainerEnvEntry9: !Sub 'PnSsTableNameDocumenti=${PnSsTableNameDocumenti}'
        ContainerEnvEntry10: !Sub 'PnSsTableDocumentiStreamArn=${PnSsTableDocumentiStreamArn}'
        ContainerEnvEntry11: !Sub 'PnSsTableDocumentiStreamMetadatiTable=${PnSsTableDocumentiStreamMetadatiTable}'
        ContainerEnvEntry12: !Sub 'PnSsQueueNameStagingBucket=${PnSsQueueNameStagingBucket}'
        ContainerEnvEntry20: !Sub 'pst=${PresignedUrlMinutesLifespan}'
        ContainerEnvEntry21: !Sub 'stayHotTime=${PnSsUriBuilderstayHotTime}'
        ContainerEnvEntry22: !Sub 'PnSsBucketLockRetentionMode=GOVERNANCE'
        ContainerEnvEntry30: !Sub 'PnSsArubaCertId=${PnSsArubaCertId}'
        ContainerEnvEntry31: !Sub 'PnSsArubaEnabledLog=${PnSsArubaEnabledLog}'
        ContainerEnvEntry32: !Sub 'PnSsArubaSignWsdlUrl=${PnSsArubaSignWsdlUrl}'
        ContainerEnvEntry33: !Sub 'PnSsArubaQname=${PnSsArubaQname}'
        ContainerEnvEntry34: !Sub 'PnSsArubaSignService=${PnSsArubaSignService}'
        ContainerEnvEntry40: !Sub 'StateMachineBaseUrl=http://${ApplicationLoadBalancerDomain}:8080'
        ContainerEnvEntry41: !Sub 'InternalBaseUrl=http://${ApplicationLoadBalancerDomain}:8080'
        MappedPaths: '/safestorage/*,/safe-storage/*'
        ECSClusterName: !Ref ECSClusterName
        Subnets: !Ref SubnetsIds
        VpcId: !Ref VpcId
        EcsDefaultSecurityGroup: !Ref EcsDefaultSecurityGroup
        LoadBalancerListenerArn: !Ref ApplicationLoadBalancerListenerArn
        LoadbalancerRulePriority: !Ref MicroserviceNumber
        # CloudwatchLogKinesisStreamArn: !Ref LogsKinesisSourceStreamArn
        TaskRoleManagedPolicyArn: !Ref PnSsManagedPolicy
        # HealthCheckPath: 
  
  PnSsManagedPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: 'String'
      ManagedPolicyName: !Ref PnSsManagedPolicyName
      PolicyDocument: 
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - 'dynamodb:*GetItem'
              - 'dynamodb:Query'
              - 'dynamodb:Describe*'
              - 'dynamodb:Scan'
              - 'dynamodb:List*'
              - 'dynamodb:DeleteItem'
              - 'dynamodb:Batch*'
              - 'dynamodb:PartiQL*'
              - 'dynamodb:Update*'
              - 'dynamodb:Put*'
              - 'dynamodb:GetRecords'
              - 'dynamodb:GetShardIterator'
            Resource:
              - !Sub '${PnSsTableArnAnagraficaClient}'
              - !Sub '${PnSsTableArnTipologieDocumenti}'
              - !Sub '${PnSsTableArnDocumenti}'
              - !Sub '${PnSsTableDocumentiStreamArn}'
          - Sid: 'FullAccesStreamMetadataTable'
            Effect: Allow
            Action:
              - 'dynamodb:*'
            Resource:
              - !Join [ '', [ !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/' , '*', !Ref PnSsTableDocumentiStreamMetadatiTable , '*']]
          - Sid: 'CloudWatchPutMetricData'
            Effect: Allow
            Action:
              - 'cloudwatch:PutMetricData'
            Resource:
              - '*'
          - Effect: Allow
            Action:
              - 's3:List*'
              - 's3:GetBucket*'
              - 's3:GetObject*'
              - 's3:*MultipartUpload*'
              - 's3:*LifecycleConfiguration'
              - 's3:*Replication*'
              - 's3:Replicate*'
              - 's3:PutBucket*'
              - 's3:PutObject*'
              - 's3:RestoreObject'
            Resource:
              - !Sub '${PnSsBucketArn}'
              - !Join [ '', [ !Sub '${PnSsBucketArn}' , '/*']]
              - !Sub '${PnSsStagingBucketArn}'
              - !Join [ '', [ !Sub '${PnSsStagingBucketArn}' , '/*']]
          - Effect: Allow
            Action:
              - 'sqs:ReceiveMessage'
              - 'sqs:DeleteMessage'
              - 'sqs:PurgeQueue'
              - 'sqs:Get*'
              - 'sqs:List*'
              - 'sqs:SendMessage'
            Resource:
              - !Sub '${PnSsQueueArnStagingBucket}'
              - !Sub '${PnSsQueueArnNotificheExt1}'
          - Effect: Allow
            Sid: 'ReadFromSecretsManagerFirmaPEC'
            Action:
              - 'secretsmanager:DescribeSecret'
              - 'secretsmanager:GetSecretValue'
            Resource:
              - !Join [ '', [ !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:' , !Ref PnEcIdentityTimemark , '*']]
              - !Join [ '', [ !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:' , !Ref PnEcIdentitySignature , '*']]
          - Effect: Allow
            Action:
              - 'kms:*'
            Resource:
              - '*'
          - Sid: 'AllowPutEventsDisponibilita'
            Effect: Allow
            Action:
              - 'events:PutEvents'
              - 'events:DescribeEventBus'
            Resource:
              - !Sub '${PnSsEventBusArnExternalNotification}'

  PnSsStagingBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Sub ${PnSsStagingBucketName}
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 's3:*'
            Effect: Allow
            Resource: !Join [ '', [ !Sub '${PnSsStagingBucketArn}' , '/*']]
            Principal:  
              AWS: 
                - !Join [ '', [ !Sub 'arn:aws:iam::${AWS::AccountId}:role/' , !GetAtt SafeStorageMicroservice.Outputs.TaskRoleName]] 

  PnSsQueuePolicyStagingBucket:
    Type: AWS::SQS::QueuePolicy
    Properties: 
      Queues: 
        - !Sub '${PnSsQueueUrlStagingBucket}'
      PolicyDocument:
        Version: '2012-10-17'
        Statement: 
          - Action: 
              - 'SQS:*'
            Effect: "Allow"
            Resource: !Sub ${PnSsQueueArnStagingBucket}
            Principal:  
              AWS: 
                - !Join [ '', [ !Sub 'arn:aws:iam::${AWS::AccountId}:role/' , !GetAtt SafeStorageMicroservice.Outputs.TaskRoleName]]
              Service:
                - 'events.amazonaws.com'
  
  PnSsQueuePolicyGestoreBucketInvokeErrors:
    Type: AWS::SQS::QueuePolicy
    Properties: 
      Queues: 
        - !Sub '${PnSsQueueUrlGestoreBucketInvokeErrors}'
      PolicyDocument:
        Version: '2012-10-17'
        Statement: 
          - Action: 
              - 'SQS:*'
            Effect: "Allow"
            Resource: !Sub ${PnSsQueueArnGestoreBucketInvokeErrors}
            Principal:  
              AWS: 
                - !Join [ '', [ !Sub 'arn:aws:iam::${AWS::AccountId}:role/' , !Ref PnSsGestoreBucketRole]]
  
  PnSsGestoreBucketRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join [ '', [!Sub 'PnSsGestoreBucketLambdaName', '-role-name']]
      Description: 'Ruolo della Lambda che implementa la funzionalità del Gestore Bucket'
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action:
          - 'sts:AssumeRole'
      Policies:
        - PolicyName: 'PnSsGestoreBucketInlinePolicy'
          PolicyDocument: 
            Version: '2012-10-17'
            Statement: 
              - Sid: 'GeneralBucketPolicy'
                Effect: 'Allow'
                Action: 
                  - 's3:List*'
                  - 's3:GetBucket*'
                  - 's3:Put*'
                  - 's3:Describe*'
                  - 's3:Get*'
                  - 's3:*MultipartUpload*'
                  - 's3:*Tag*'
                Resource:
                  - !Sub '${PnSsBucketArn}'
                  - !Join [ '', [ !Sub '${PnSsBucketArn}' , '/*']]
              - Sid: 'QueueInvokeErrorsPolicyProducer'
                Effect: 'Allow'
                Action: 
                  - 'sqs:SendMessage'
                Resource:
                  - !Sub '${PnSsQueueArnGestoreBucketInvokeErrors}'
              - Sid: 'DefaultKMSGrantRead'
                Effect: 'Allow'
                Action: 
                  - 'kms:GenerateDataKey'
                  - 'kms:Decrypt'
                  - 'events:PutEvents'
                Resource: '*'
                Condition:
                  StringLike:
                    kms:RequestAlias: 'alias/aws/sqs'

  PnSsGestoreBucketHotNotificationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt PnSsGestoreBucket.Arn
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceAccount: !Ref 'AWS::AccountId'
      SourceArn: !Ref PnSsBucketArn

  PnSsGestoreBucketStagingNotificationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt PnSsGestoreBucket.Arn
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceAccount: !Ref 'AWS::AccountId'
      SourceArn: !Ref PnSsStagingBucketArn

  PnSsGestoreBucket:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Ref PnSsGestoreBucketLambdaName
      Description: 'Pn SafeStorage Gestore Bucket'
      Handler: index.handler
      MemorySize: 1024
      Runtime: nodejs16.x
      Role: !GetAtt PnSsGestoreBucketRole.Arn
      Timeout: 240
      DeadLetterConfig: 
        TargetArn: !Ref PnSsQueueArnGestoreBucketInvokeErrors
      VpcConfig:
        SubnetIds:
          - !Select [ 0, !Split [ ",", !Ref SubnetsIds ] ]
          - !Select [ 1, !Split [ ",", !Ref SubnetsIds ] ]
          - !Select [ 2, !Split [ ",", !Ref SubnetsIds ] ]
        SecurityGroupIds:
          - !Ref PnVPCDefaultSecurityGroup
      Environment:
        Variables:
          PnSsHostname: !Ref ApplicationLoadBalancerDomain
          PnSsGestoreRepositoryPort: !Ref PnSsGestoreRepositoryPort
          PnSsGestoreRepositoryProtocol: !Ref PnSsGestoreRepositoryProtocol
          PnSsGestoreRepositoryPathGetDocument: !Ref PnSsGestoreRepositoryPathGetDocument
          PnSsGestoreRepositoryPathPatchDocument: !Ref PnSsGestoreRepositoryPathPatchDocument
          PnSsStagingBucketName: !Ref PnSsStagingBucketName

      Code:
        ZipFile: |
          "use strict";

          const http = require(process.env.PnSsGestoreRepositoryProtocol);
          const AWS = require("aws-sdk");
          const crypto = require("crypto");

          const HOSTNAME = process.env.PnSsHostname;
          const PORT = process.env.PnSsGestoreRepositoryPort;
          const PATHGET = process.env.PnSsGestoreRepositoryPathGetDocument;
          const PATHPATCH = process.env.PnSsGestoreRepositoryPathPatchDocument;
          const STAGINGBUCKET = process.env.PnSsStagingBucketName;
          const s3 = new AWS.S3();
          const EvtBridge = new AWS.EventBridge();

          exports.handler = async (event) => {
            let jsonDocument = {
              documentKey: "",
              documentState: "",
            };

            console.log("Event: ", JSON.stringify(event));
            let bucketName;
            console.log("Buket Name: " + event.Records[0].s3.bucket.name);
            console.log("Object Key: " + event.Records[0].s3.object.key);
            console.log("Object Size: " + event.Records[0].s3.object.size);
            let params = {
              Bucket: "",
              Key: "",
            };
            bucketName = event.Records[0].s3.bucket.name;
            jsonDocument.documentKey = event.Records[0].s3.object.key;
            switch (event.Records[0].eventName) {
              case "ObjectCreated:*":
                break;
              case "ObjectCreated:Put":
                if (bucketName === STAGINGBUCKET) {
                  jsonDocument.documentState = "staged";
                } else {
                  jsonDocument.contentLenght = event.Records[0].s3.object.size;
                  jsonDocument.documentState = "available";
                  params.Bucket = bucketName;
                  params.Key = jsonDocument.documentKey;
                  try {
                    const { Body } = await s3.getObject(params).promise();
                    console.log(Body);
                    const doc = await getDocumentFromDB(jsonDocument.documentKey);

                    console.log(doc.document);
                    console.log(doc.document.documentType.checksum);
                    console.log(JSON.stringify(doc.document.documentType.checksum));

                    jsonDocument.checkSum = crypto
                      .createHash(doc.document.documentType.checksum)
                      .update(Body)
                      .digest("hex");
                    
                  } catch (error) {
                    console.log(error);
                    const messageError = `Errore nella lavorazione dell'oggetto ${jsonDocument.documentKey} dal bucket ${bucketName}. Verificare che l'oggetto esiste nel bucket o sul database Dynamo.`;
                    console.log(messageError);
                    throw new Error(messageError);
                  }
                }
                break;
              case "ObjectCreated:Copy":
                jsonDocument.documentState = "available";
                break;
              case "ObjectRestore:Completed":
                jsonDocument.documentState = "available";
                break;
              case "LifecycleTransition":
                jsonDocument.documentState = "freezed";
                break;
              case "ObjectRestore:Delete":
                jsonDocument.documentState = "freezed";
                break;
              case "LifecycleExpiration:Delete":
                jsonDocument.documentState = "deleted";
                break;
              case "ObjectRemoved:DeleteMarkerCreated":
                jsonDocument.documentState = "deleted";
                break;
              default:
                return;
            }
            
            console.log("Before dynamo update: ", JSON.stringify(jsonDocument));
            
            try {
              const res = await updateDynamo(jsonDocument);
              console.log("Dynamo update response", res);
              
              const checksumBuf = Buffer.from(res.document.checkSum, "hex")
              
              const evtBody = {
                  key: res.document.documentKey ,
                  versionId: 'v1' ,
                  documentType: res.document.documentType.tipoDocumento ,
                  documentStatus: res.document.documentLogicalState ,
                  contentType: res.document.contentType ,
                  contentLength: res.document.contentLenght ,
                  checksum: checksumBuf.toString('base64') ,
                  retentionUntil: res.document.retentionUntil ,
                  client_short_code: res.document.clientShortCode
                }
              console.log( "Event to be sent to EvtBridge", evtBody);
              await sendSafeStorageEventBridge( evtBody );
              
              console.log("############## EXIT  ####################");
              return res;
            } catch (err) {
              //console.log(err);
              const retMessgeError = "Errore nella patch su DynamoDB o nella put di EventBridge.";
              console.log(retMessgeError, err);
              throw new Error(retMessgeError);
            }
          };
          function getDocumentFromDB(docKey) {
            const options = {
              method: "GET",
              hostname: HOSTNAME,
              port: PORT,
              path: PATHGET + "/" + docKey,
              headers: {
                "Content-Type": "application/json",
              },
            };
            return new Promise((resolve, reject) => {
              const req = http.request(options, (res) => {
                let responseBody = "";

                res.on("data", (chunk) => {
                  responseBody += chunk;
                });

                res.on("end", () => {
                  resolve(JSON.parse(responseBody));
                });
              });

              req.on("error", (err) => {
                console.error(err);
                reject(err);
              });
              req.end();
            });
          }
          function updateDynamo(data) {
            const options = {
              method: "PATCH",
              hostname: HOSTNAME,
              port: PORT,
              path: PATHPATCH + "/" + data.documentKey,
              headers: {
                "Content-Type": "application/json",
              },
            };
            return new Promise((resolve, reject) => {
              const req = http.request(options, (res) => {
                let responseBody = "";
                res.on("data", (chunk) => {
                  responseBody += chunk;
                });
                res.on("end", () => {
                  //resolve(JSON.parse(responseBody));
                  switch (res.statusCode) {
                    case 200:
                      resolve(JSON.parse(responseBody));
                      break;
                    case 500:
                      reject( JSON.parse(responseBody) );
                      break;
                    default:
                      reject( JSON.parse(responseBody) );
                      break;
                  }
                });
              });
              req.on("error", (err) => {
                console.error(err);
                reject(err);
              });
              req.write(JSON.stringify(data));
              req.end();
            });
          }

          function sendSafeStorageEventBridge( body ) {
            
            var params = {
              Entries: [
                {
                  Detail: JSON.stringify( body ) ,
                  DetailType: 'SafeStorageOutcomeEvent',
                  Resources: [],
                  Source: 'SafeStorageMock'
                }
              ]
            };
            
            return new Promise( ( accept, reject) => {
              EvtBridge.putEvents(params, (err, data) => {
                if (err) {
                  reject( err )
                } else {
                  accept( data );
                }
              });
            });

          }

