AWSTemplateFormatVersion: 2010-09-09
Description: 'Example microservice deploy'

Parameters:
  ProjectName:
    Type: String
    Description: 'Usually pn can be pnXYZ where XYZ are the feature number, useful to create
      experimental environments without crash official development environment'

  AlarmSNSTopicArn:
    Type: String
    Description: ARN of alarm topic

  # WebApiDnsName:
  #   Type: String
  #   Description: 'The DNS name used for WEB rest API.'
  
  # CorsAllowedDomains:
  #   Type: String
  #   Description: 'Comma separated list of domains allowed to make cross origin request'

  ContainerImageUri:
    Type: String
    Description: 'Exact container image URI with full repository and image digest'

  MicroserviceNumber:
    Type: Number
    Description: 'Disambiguation useful for load balancer rules'

  TemplateBucketBaseUrl:
    Type: String
    Description: 'The S3 bucket from which to fetch the templates used by this stack.'

  ECSClusterName:
    Type: String
    Description: 'The name of the ECS cluster where the microservice is going to be deployed'

  SubnetsIds:
    Type: String
    Description: 'subnets ids comma separated list. Where to deploy the microservice'

  VpcId:
    Type: String
    Description: 'VpcId where the microservice is going to be deployed'
  
  EcsDefaultSecurityGroup:
    Type: String
    Description: 'Default security group required by infrastructure'

  ApplicationLoadBalancerListenerArn:
    Type: String
    Description: 'Load balancer listener where HTTP endpoints is going to be registered'

  ApplicationLoadBalancerDomain:
    Type: String
    Description: 'Base URL of the load balancer where the service is going to be reachable'

  NetworkLoadBalancerLink:
    Type: String
    Description: 'network load balancer link for API-GW'
  
  # LogsKinesisSourceStreamArn:
  #   Type: String
  #   Description: 'Kinesis stream that receive logs'
  
  Version:
    Type: String
    Description: 'keep track of used projects commitIds'

  PnSsTableNameAnagraficaClient:
    Type: String
    Description: 'Nome della tabella SS Anagrafica Client'

  PnSsTableArnAnagraficaClient:
    Type: String
    Description: 'ARN della Tabella DynamoDB relativa alla Macchina a Stati'
  
  PnSsTableNameTipologieDocumenti:
    Type: String
    Description: 'Nome della tabella SS Tipologie Documenti'

  PnSsTableArnTipologieDocumenti:
    Type: String
    Description: 'ARN della tabella SS Tipologie Documenti'
  
  PnSsTableNameDocumenti:
    Type: String
    Description: 'Nome tabella SS Documenti' 

  PnSsTableArnDocumenti:
    Type: String
    Description: 'ARN della tabella SS Documenti'

  PnSsBucketName:
    Type: String
    Description: 'Nome del Bucket SS'

  PnSsBucketArn:
    Type: String
    Description: 'ARN del Bucket SS'
  
  PnSsStagingBucketName:
    Type: String
    Description: 'Nome Bucket SS Staging'

  PnSsStagingBucketArn:
    Type: String
    Description: 'ARN Bucket SS Staging'

  PnSsQueueNameStagingBucket:
    Type: String
    Description: 'Nome coda per notifiche SS Staging Bucket'

  PnSsQueueArnStagingBucket:
    Type: String
    Description: 'ARN coda per notifiche SS Staging Bucket'

  PnSsQueueUrlStagingBucket:
    Type: String
    Description: 'URL coda per notifiche SS Staging Bucket'

  PnSsDLQueueNameStagingBucket:
    Type: String
    Description: 'Nome coda DLQ per notifiche SS Staging Bucket'
  
  PnSsManagedPolicyName:
    Type: String
    Description: 'Nome della managed policy associata alla state machine'
    Default: 'PnSsManagedPolicyName'

  PnSsGestoreBucketLambdaName:
    Type: String
    Description: 'Nome della Lambda function che implementa la funzionalità del Gestore Bucket'

  PresignedUrlMinutesLifespan:
    Type: String
    Description: 'Minuti di validità dei pre-signed url prima di scadere'

  PnEcIdentityTimemark:
    Type: String
    Description: 'Secret ID for Identity Timemark'

  PnEcIdentitySignature:
    Type: String
    Description: 'Secret ID for Identity Signature'


Resources:

  # PN-TemplateBeMs microservice
  SafeStorageMicroservice:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: !Sub '${TemplateBucketBaseUrl}/fragments/ecs-service.yaml'
      Parameters:
        MicroServiceUniqueName: !Sub '${ProjectName}-safe-storage'
        CpuValue: 2048
        MemoryAmount: 6GB
        AlarmSNSTopicArn: !Ref AlarmSNSTopicArn
        ContainerImageURI: !Sub '${ContainerImageUri}'
        ContainerEnvEntry1: !Sub 'AWS_REGIONCODE=${AWS::Region}'
        ContainerEnvEntry2: !Sub 'StateMachineBaseUrl=http://${ApplicationLoadBalancerDomain}:8080'
        ContainerEnvEntry3: !Sub 'PnSsBucketName=${PnSsBucketName}'
        ContainerEnvEntry4: !Sub 'PnSsBucketArn=${PnSsBucketArn}'
        ContainerEnvEntry5: !Sub 'PnSsStagingBucketName=${PnSsStagingBucketName}'
        ContainerEnvEntry6: !Sub 'PnSsStagingBucketArn=${PnSsStagingBucketArn}'
        ContainerEnvEntry7: !Sub 'PnSsTableNameAnagraficaClient=${PnSsTableNameAnagraficaClient}'
        ContainerEnvEntry8: !Sub 'PnSsTableNameTipologieDocumenti=${PnSsTableNameTipologieDocumenti}'
        ContainerEnvEntry9: !Sub 'PnSsTableNameDocumenti=${PnSsTableNameDocumenti}'
        ContainerEnvEntry10: !Sub 'PnSsQueueNameStagingBucket=${PnSsQueueNameStagingBucket}'
        ContainerEnvEntry11: !Sub 'pst=${PresignedUrlMinutesLifespan}'
        MappedPaths: '/safestorage/*,/safe-storage/*'
        ECSClusterName: !Ref ECSClusterName
        Subnets: !Ref SubnetsIds
        VpcId: !Ref VpcId
        EcsDefaultSecurityGroup: !Ref EcsDefaultSecurityGroup
        LoadBalancerListenerArn: !Ref ApplicationLoadBalancerListenerArn
        LoadbalancerRulePriority: !Ref MicroserviceNumber
        # CloudwatchLogKinesisStreamArn: !Ref LogsKinesisSourceStreamArn
        TaskRoleManagedPolicyArn: !Ref PnSsManagedPolicy
        # HealthCheckPath: 
  
  PnSsManagedPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: 'String'
      ManagedPolicyName: !Ref PnSsManagedPolicyName
      PolicyDocument: 
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - 'dynamodb:*GetItem'
              - 'dynamodb:Query'
              - 'dynamodb:Describe*'
              - 'dynamodb:Scan'
              - 'dynamodb:List*'
              - 'dynamodb:DeleteItem'
              - 'dynamodb:Batch*'
              - 'dynamodb:PartiQL*'
              - 'dynamodb:Update*'
              - 'dynamodb:Put*'
            Resource:
              - !Sub '${PnSsTableArnAnagraficaClient}'
              - !Sub '${PnSsTableArnTipologieDocumenti}'
              - !Sub '${PnSsTableArnDocumenti}'
          - Effect: Allow
            Action:
              - 's3:List*'
              - 's3:GetBucket*'
              - 's3:GetObject*'
              - 's3:*MultipartUpload*'
              - 's3:*LifecycleConfiguration'
              - 's3:*Replication*'
              - 's3:Replicate*'
              - 's3:PutBucket*'
              - 's3:PutObject*'
              - 's3:RestoreObject'
            Resource:
              - !Sub '${PnSsBucketArn}'
              - !Join [ '', [ !Sub '${PnSsBucketArn}' , '/*']]
              - !Sub '${PnSsStagingBucketArn}'
              - !Join [ '', [ !Sub '${PnSsStagingBucketArn}' , '/*']]
          - Effect: Allow
            Action:
              - 'sqs:ReceiveMessage'
              - 'sqs:DeleteMessage'
              - 'sqs:PurgeQueue'
              - 'sqs:Get*'
              - 'sqs:List*'
            Resource:
              - !Sub '${PnSsQueueArnStagingBucket}'
          - Effect: Allow
            Sid: 'ReadFromSecretsManagerFirmaPEC'
            Action:
              - 'secrets:DescribeSecret'
              - 'secrets:GetSecretValue'
            Resource:
              - !Join [ '', [ !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:' , !Ref PnEcIdentityTimemark , '*']]
              - !Join [ '', [ !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:' , !Ref PnEcIdentitySignature , '*']]
          - Effect: Allow
            Action:
              - 'kms:*'
            Resource:
              - '*'

  PnSsStagingBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Sub ${PnSsStagingBucketName}
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 's3:*'
            Effect: Allow
            Resource: !Join [ '', [ !Sub '${PnSsStagingBucketArn}' , '/*']]
            Principal:  
              AWS: 
                - !Join [ '', [ !Sub 'arn:aws:iam::${AWS::AccountId}:role/' , !GetAtt SafeStorageMicroservice.Outputs.TaskRoleName]] 

  PnSsQueuePolicyStagingBucket:
    Type: AWS::SQS::QueuePolicy
    Properties: 
      Queues: 
        - !Sub '${PnSsQueueUrlStagingBucket}'
      PolicyDocument:
        Version: '2012-10-17'
        Statement: 
          - Action: 
              - 'SQS:*'
            Effect: "Allow"
            Resource: !Sub ${PnSsQueueArnStagingBucket}
            Principal:  
              AWS: 
                - !Join [ '', [ !Sub 'arn:aws:iam::${AWS::AccountId}:role/' , !GetAtt SafeStorageMicroservice.Outputs.TaskRoleName]]
              Service:
                - 'events.amazonaws.com'
           
  PnSsGestoreBucketRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join [ '', [!Sub 'PnSsGestoreBucketLambdaName', '-role-name']]
      Description: 'Ruolo della Lambda che implementa la funzionalità del Gestore Bucket'
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action:
          - 'sts:AssumeRole'
      Policies:
        - PolicyName: 'PnSsGestoreBucketInlinePolicy'
          PolicyDocument: 
            Version: '2012-10-17'
            Statement: 
              - Sid: 'GeneralBucketPolicy'
                Effect: 'Allow'
                Action: 
                  - 's3:List*'
                  - 's3:GetBucket*'
                  - 's3:Put*'
                  - 's3:Describe*'
                  - 's3:Get*'
                  - 's3:*MultipartUpload*'
                  - 's3:*Tag*'
                Resource:
                  - !Sub '${PnSsBucketArn}'
                  - !Join [ '', [ !Sub '${PnSsBucketArn}' , '/*']]

  PnSsGestoreBucketNotificationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt PnSsGestoreBucket.Arn
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceAccount: !Ref 'AWS::AccountId'
      SourceArn: !Ref PnSsBucketArn

  PnSsGestoreBucket:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Ref PnSsGestoreBucketLambdaName
      Description: 'Pn SafeStorage Gestore Bucket'
      Handler: index.handler
      MemorySize: 512
      Runtime: nodejs16.x
      Role: !GetAtt PnSsGestoreBucketRole.Arn
      Timeout: 240
      Environment:
        Variables:
          SafeStorageBaseUrl: !Sub http://${ApplicationLoadBalancerDomain}:8080'
      Code:
        ZipFile: |
          "use strict";
          const https = require("https");
          const AWS = require("aws-sdk");
          const s3 = new AWS.S3();
          const HOSTNAME = process.env.SafeStorageBaseUrl || "localhost";

          var jsonDocument = {
            documentKey: "",
            documentState: "",
            checkSum: "",
            contentLenght: 0,
          };
          /**
          * Event Handler
          *
          * @param {*} event
          * @returns
          */
          exports.handler = async (event) => {
            console.log(event);
            var bucketName;
            console.log("Buket Name: " + event.Records[0].s3.bucket.name);
            console.log("Object Key: " + event.Records[0].s3.object.key);
            console.log("Object Size: " + event.Records[0].s3.object.size);
            var params = {
              Bucket: "",
              Key: "",
            };
            //event.Records.forEach((record) => {
            bucketName = event.Records[0].s3.bucket.name;
            jsonDocument.documentKey = event.Records[0].s3.object.key;
            switch (event.Records[0].eventName) {
              case "ObjectCreated:*":
                break;
              case "ObjectCreated:Put":
                jsonDocument.contentLenght = event.Records[0].s3.object.size;
                jsonDocument.documentState = "AVAILABLE";
                params.Bucket = bucketName;
                params.Key = jsonDocument.documentKey;
                const { Body } = await s3.getObject(params).promise();
                console.log(Body);
                var doc = await getDocumentFromDB(jsonDocument.documentKey);
                console.log(doc);
                jsonDocument.checkSum = hashDocument(Body, doc.documentType);
                console.log(jsonDocument);
                break;
              case "ObjectRestore:Completed":
                jsonDocument.documentState = "AVAILABLE";
                break;
              case "LifecycleTransition":
                jsonDocument.documentState = "FREEZED";
                break;
              case "ObjectRestore:Delete":
                jsonDocument.documentState = "FREEZED";
                break;
              case "LifecycleExpiration:Delete":
                jsonDocument.documentState = "DELETED";
                break;
              case "ObjectRemoved:Delete":
                jsonDocument.documentState = "DELETED";
                break;
              default:
                const response = {
                  statusCode: 200,
                };
              return response;
            }
            const res = await updateDynamo(jsonDocument);
            console.log(res);
            console.log("############## EXIT  ####################");
            const response = {
              statusCode: 200,
            };
            return response;
          };
          /**
          * Do a request with options not provided.
          *
          * @param {Object} options
          * @param {Object} data
          * @return {Promise} a promise of request
          */
          function getDocumentFromDB(docKey) {
            const options = {
              method: "GET",
              hostname: HOSTNAME,
              path: "/safestorage/internal/v1/documents/" + docKey,
              headers: {
                "Content-Type": "application/json",
              },
            };
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                // res.setEncoding("utf8");
                let responseBody = "";

                res.on("data", (chunk) => {
                  responseBody += chunk;
                });

                res.on("end", () => {
                  resolve(JSON.parse(responseBody));
                });
              });

              req.on("error", (err) => {
                console.error(err);
                reject(err);
              });

              // req.write(data);
              req.end();
            });
          }

          var crypto = require("crypto");

          const hashDocument = (document, docType) => {
            var hash;
            if (docType == "PN_AAR") {
              hash = crypto.createHash("md5").update(document).digest("hex");
            } else {
              hash = crypto.createHash("sha256").update(document).digest("hex");
            }

            return hash;
          };

          /**
          * TO DO
          */
          function updateDynamo(data) {
            const options = {
              method: "PATCH",
              hostname: HOSTNAME,
              path: "/safestorage/internal/v1/documents/" + data.documentKey,
              headers: {
                "Content-Type": "application/json",
              },
            };
            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                // res.setEncoding("utf8");
                let responseBody = "";

                res.on("data", (chunk) => {
                  responseBody += chunk;
                });

                res.on("end", () => {
                  resolve(JSON.parse(responseBody));
                });
              });

              req.on("error", (err) => {
                console.error(err);
                reject(err);
              });

              req.write(data);
              req.end();
            });
          }
